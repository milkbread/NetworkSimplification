<html>
<head>
	<title>Playing with quadtrees</title>
	<script src="d3.v3.min.js"></script>
	<style type="text/css">
		rect {
			fill: none;
			stroke: rgba(0%, 0%, 0%, 1);
		}

		.point {
			fill: rgba(20%, 20%, 20%, .3);
			stroke: none;
		}

		.line {
			stroke: rgba(0%, 0%, 0%, .3);
			fill: none;
			pointer-events: none;
		}

		.consPoint {
			fill: rgba(100%, 0%, 0%, .7);
			stroke: none;
		}

	</style>
</head>
<body>
<script type="text/javascript">
	// Concept for a DataPoint-Class
	// function DataPoint(input) {
	// 	var self = this;
	// 	self.coords = input.coords;
	// }

	// Basic variables
	var width = 960,
	    height = 700,
	    scale = 300,
		groupScale = 1,
		groupPositionX = oldGroupPositionX = 0,
		groupPositionY = oldgroupPositionY = 0;


	// prepare the major SVG-Visualisation area
	var svg = d3.select("body").append("svg")
	    .attr("width", width)
	    .attr("height", height)
	    .on("mousedown", startMoving)
	    .on("mouseup", stopMoving)
		.call(
	    	d3.behavior.zoom().on("zoom", reScale)
		);
	// prepare the SVG-Groups and corresponding object-variables
	var rectGroup = svg.append("g"),
		pointGroup = svg.append("g"),
		lineGroup = svg.append("g"),
		groups = [rectGroup, pointGroup, lineGroup],
		rectangles, points, lines;

	function processData(lineData, pointData) {
		var extent = getExtent(lineData); //[[minX, minY], [maxX, maxY]]
		function projection(d) { return [(d[0]-extent[0][0]) * scale, (d[1]-extent[0][1]) * scale]; }
		var path = d3.geo.path()
				.projection(projection),
			dataPoints = getAllPoints(lineData, extent, projection);

		// Inititialise the quadtree
		var rawQuadtree = d3.geom.quadtree();
		// rawQuadtree.extent(extent)			//can generate: 'Maximum call stack size exceeded'
		var quadtree = rawQuadtree(dataPoints);

		// Draw all rectangles by using a collapsed quadtree
		rectangles = rectGroup.selectAll(".node")
		    .data(nodes(quadtree))
				.enter().append("rect")
					.attr("x", function(d) { return d.x; })
					.attr("y", function(d) { return d.y; })
					.attr("width", function(d) { return d.width; })
					.attr("height", function(d) { return d.height; })

		// Draw all points of the lines
		points = pointGroup.selectAll(".point")
			.data(dataPoints)
				.enter().append("circle")
					.attr("class", "point")
					.attr("cx", function(d) { return d[0]; })
					.attr("cy", function(d) { return d[1]; });

		// Draw all lines
		lines = lineGroup.selectAll(".line")
			.data(lineData.features)
				.enter().append("path")
					.attr("d", function(d){ return path(d.geometry); })
					.attr("class", "line");

		constrainingPoints = pointGroup.selectAll(".consPoint")
			.data(pointData.features)
				.enter().append("circle")
					.attr("cx", function(d) { return projection(d.geometry.coordinates)[0]; })
					.attr("cy", function(d) { return projection(d.geometry.coordinates)[1]; })
					.attr("class", "consPoint");

		transformGroup();
	}
	// Load lineData and do visualisations
	d3.json("lines.json", function(error, lineData) {
		d3.json("points.json", function(error, pointData) {
			processData(lineData, pointData);
		});
	});

	// Collapse the quadtree into an array of rectangles.
	function nodes(quadtree) {
	  var nodes = [];
	  quadtree.visit(function(node, x1, y1, x2, y2) {
	    nodes.push({x: x1, y: y1, width: x2 - x1, height: y2 - y1});
	  });
	  return nodes;
	}

	function transformGroup() {
		// Transform all groups
		groups.forEach(function(group) {
			group.attr("transform", function(d){
				return "scale("+groupScale+", -"+groupScale+") translate("+groupPositionX+",-" + (height + groupPositionY) + ")"; });
		})
		// Re-Scale size of points and lines
		rectangles.style("stroke-width", .1 / groupScale);
		points.attr("r", 3 / groupScale);
		lines.style("stroke-width", 1 / groupScale);
		constrainingPoints.attr("r", 5 / groupScale);
	}

	function startMoving() {
		var startingPosition = d3.mouse(this);
		svg.on("mousemove", function() {
			var currentPosition = d3.mouse(this);
			groupPositionX = oldGroupPositionX + currentPosition[0] - startingPosition[0];
			groupPositionY = oldgroupPositionY + currentPosition[1] - startingPosition[1];
			transformGroup();
		});
	}

	function stopMoving() {
		svg.on("mousemove", null);
		oldGroupPositionX = groupPositionX;
		oldGroupPositionY = groupPositionY;
	}

	function reScale() {
  		//detect the mousewheel event
		if (d3.event.sourceEvent.type.indexOf("wheel") != -1 || d3.event.sourceEvent.type.indexOf("wheel") != -1){
	  		var scaleChange = .1;
	  		if (d3.event.sourceEvent.wheelDelta){
				if (d3.event.sourceEvent.wheelDelta < 0){
					scaleChange =  scaleChange * -1;
				}
			}else{
				if (d3.event.sourceEvent.detail < 0){
					scaleChange =  scaleChange * -1;
				}
			}
			// Calculate the change of the scale and the new translation-parameter
			groupScale = groupScale + scaleChange;

			transformGroup();
		}
  	}

  	function getExtent(elements) {
  		var extent = [[181, 181], [-181, -181]];
  		elements.features.forEach(function(feature) {
			feature.geometry.coordinates.forEach(function(point) {
				// build the extent
				if (point[0] < extent[0][0]) extent[0][0] = point[0];
				if (point[1] < extent[0][1]) extent[0][1] = point[1];
				if (point[0] > extent[1][0]) extent[1][0] = point[0];
				if (point[1] > extent[1][1]) extent[1][1] = point[1];
			});
		});
		return extent;
  	}

  	function getAllPoints(elements, extent, projection) {
  		var dataPoints = [];
		elements.features.forEach(function(feature) {
			feature.geometry.coordinates.forEach(function(point) {
				dataPoints.push(projection(point));
			});
		});
		return dataPoints;
  	}
</script>
</body>
</html>